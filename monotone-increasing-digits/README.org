* Leetcode: Monotone Increasing Digits                           :BLOG:Amusing:
#+STARTUP: showeverything
#+OPTIONS: toc:nil \n:t ^:nil creator:nil d:nil
:PROPERTIES:
:type:     greedy, inspiring
:END:
---------------------------------------------------------------------
Monotone Increasing Digits
---------------------------------------------------------------------
Similar Problems:
- Tag: [[https://brain.dennyzhang.com/tag/monotonestack][#monotonestack]]
---------------------------------------------------------------------
Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.

(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.)

Example 1:
#+BEGIN_EXAMPLE
Input: N = 10
Output: 9
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: N = 1234
Output: 1234
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: N = 332
Output: 299
#+END_EXAMPLE
Note: N is an integer in the range [0, 10^9].

Github: [[url-external:https://github.com/DennyZhang/challenges-leetcode-interesting/tree/master/monotone-increasing-digits][challenges-leetcode-interesting]]

Credits To: [[url-external:https://leetcode.com/problems/monotone-increasing-digits/description/][leetcode.com]]

Leave me comments, if you have better ways to solve.

#+BEGIN_SRC python
## Blog link: https://brain.dennyzhang.com/monotone-increasing-digits
## Basic Ideas:
##   Scan from right to left
##   If we have left digit which is no smaller than this one, we evaluate that one digit
##
## Sample Data:
##     2342
##     2<3, so we get 2299
## Complexity:
class Solution(object):
    def monotoneIncreasingDigits(self, N):
        """
        :type N: int
        :rtype: int
        """
        l = list(str(N))
        length = len(l)
        for i in range(length): l[i] = ord(l[i]) - ord('0')
        
        should_change = False
        for i in range(0, length-1):
            if l[i]>l[i+1]:
                should_change = True
                break

        index = length
        i = length - 1
        while i > 0:
            for j in range(i-1, -1, -1):
                if l[j] >= l[i]:
                    index = min(index, j)
                    i = j+1
                    break
            i = i-1

        # make the change
        if should_change:
            l[index] -= 1
            for i in range(index+1, length): l[i] = 9

        # get the result
        res = 0
        for i in range(length): res = res*10+l[i]
        return res

s = Solution()
print(s.monotoneIncreasingDigits(101)) # 99
print(s.monotoneIncreasingDigits(120)) # 119
print(s.monotoneIncreasingDigits(332)) # 299
print(s.monotoneIncreasingDigits(10)) # 9
print(s.monotoneIncreasingDigits(668841)) # 667999
#+END_SRC
