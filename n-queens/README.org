* Leetcode: N-Queens                                              :BLOG:Hard:
#+STARTUP: showeverything
#+OPTIONS: toc:nil \n:t ^:nil creator:nil d:nil
:PROPERTIES:
:type:     #misc
:END:
---------------------------------------------------------------------
N-Queens
---------------------------------------------------------------------
The n-queens puzzle is the problem of placing n queens on an n√ón chessboard such that no two queens attack each other.

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
#+BEGIN_EXAMPLE
For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
#+END_EXAMPLE

Github: [[url-external:https://github.com/DennyZhang/challenges-leetcode-interesting/tree/master/n-queens][challenges-leetcode-interesting]]

Credits To: [[url-external:https://leetcode.com/problems/n-queens/description/][Leetcode.com]]

Leave me comments, if you know how to solve.

#+BEGIN_SRC python
## Basic Ideas: backtracking. Try with both possibilities for each unexplored positions
##
## Complexity:
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        if n <= 0:
            return None
        board = []
        for i in xrange(n):
            board.append([None]*n)
        self.res = []
        self.mySolveNQueens(board, n, 0, 0, 0)
        return self.res

    def mySolveNQueens(self, board, n, queen_count, irow, icol):
        if irow == n:
            if queen_count == n:
                item = []
                for row in board:
                    item.append(''.join(row))
                self.res.append(item)
            return

        irow2, icol2 = None, None
        if icol == n - 1:
            irow2, icol2 = irow + 1, 0
        else:
            irow2, icol2 = irow, icol + 1

        # place Q
        if self.isNQuees(board, n, irow, icol):
            board[irow][icol] = 'Q'
            self.mySolveNQueens(board, n, queen_count + 1, irow2, icol2)

        board[irow][icol] = '.'
        self.mySolveNQueens(board, n, queen_count, irow2, icol2)

    def isNQuees(self, board, n, irow, icol):
        for index in xrange(n):
            # check row
            if index == icol: continue
            if board[irow][index] == 'Q':
                return False

        for index in xrange(n):
            # check column
            if index == irow: continue
            if board[index][icol] == 'Q':
                return False

        for i in xrange(n):
            for j in xrange(n):
                if irow == i and icol == j:
                    continue
                if abs(irow-i) == abs(icol-j) and board[i][j] == 'Q':
                    return False
        return True

s = Solution()
print s.solveNQueens(4)
#+END_SRC
