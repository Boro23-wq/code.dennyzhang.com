* Leetcode: Word Ladder                                              :BLOG:Basic:
#+STARTUP: showeverything
#+OPTIONS: toc:nil \n:t ^:nil creator:nil d:nil
:PROPERTIES:
:type:     #misc
:END:
---------------------------------------------------------------------
Word Ladder
---------------------------------------------------------------------
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

1. Only one letter can be changed at a time.
- Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
#+BEGIN_EXAMPLE
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
#+END_EXAMPLE

Note:
- Return 0 if there is no such transformation sequence.
- All words have the same length.
- All words contain only lowercase alphabetic characters.
- You may assume no duplicates in the word list.
- You may assume beginWord and endWord are non-empty and are not the same.

UPDATE (2017/1/20):
The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.

Github: [[url-external:https://github.com/DennyZhang/challenges-leetcode-interesting/tree/master/word-ladder][challenges-leetcode-interesting]]

Credits To: [[url-external:https://leetcode.com/problems/word-ladder/description/][leetcode.com]]

Leave me comments, if you have better ways to solve.

#+BEGIN_SRC python
## Blog link: https://brain.dennyzhang.com/word-ladder
## Basic Ideas: BFS. Find the shortest path from point1 to point2
##              Queue is the candidate list. 
##              checked_list
##              remaining_list
##
## Complexity:
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        queue = []
        checkedList = []
        self.addCandidates(beginWord, queue, wordList, checkedList)

        level = 1
        while len(queue) != 0:
            level += 1
            for i in xrange(len(queue)):
                word = queue[0]
                if word == endWord: return level
                del queue[0]
                # mark as checked
                checkedList.append(word)
                # find the next candidates
                self.addCandidates(word, queue, wordList, checkedList)
        return 0

    def addCandidates(self, checkWord, queue, wordList, checkedList):
        i = 0
        while i<len(wordList):
            word = wordList[i]
            if word not in checkedList and self.onlyOneDiff(checkWord, word):
                queue.append(word)
                del wordList[i]
            else:
                i += 1

    def onlyOneDiff(self, word1, word2):
        diff_count = 0
        for i in xrange(len(word1)):
            if word1[i] != word2[i]:
                diff_count += 1
            if diff_count > 1: return False
        return diff_count == 1
#+END_SRC
